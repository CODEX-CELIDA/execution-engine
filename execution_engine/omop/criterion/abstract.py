import copy
import re
from abc import ABC, abstractmethod

import sqlparse


class AbstractCriterion(ABC):
    """
    Abstract base class for Criterion and CriterionCombination.
    """

    def __init__(self, name: str, exclude: bool = False):
        self._name: str = re.sub(r"[ \t]", "-", name)
        self._exclude: bool = exclude

    @property
    def exclude(self) -> bool:
        """Return the exclude flag."""
        return self._exclude

    @property
    def type(self) -> str:
        """
        Get the type of the criterion.
        """
        return self.__class__.__name__

    @property
    def name(self) -> str:
        """
        Get the name of the criterion.
        """
        return str(self)

    def invert_exclude(self, inplace: bool = False) -> "AbstractCriterion":
        """
        Invert the exclude flag.
        """
        if inplace:
            self._exclude = not self._exclude
            return self
        else:
            criterion = copy.deepcopy(self)
            criterion._exclude = not criterion._exclude
            return criterion

    def __str__(self) -> str:
        """
        Get the name of the criterion.
        """
        return self.type + "_" + self._name


class Criterion(AbstractCriterion):
    """A criterion in a cohort definition."""

    def __init__(self, name: str, exclude: bool = False):
        super().__init__(name, exclude)
        self._table_in: str | None = None
        self._table_out: str | None = None

    @property
    def table_in(self) -> str:
        """
        Get the name of the table to use as input for this criterion.
        """
        if self._table_in is None:
            raise ValueError("table_in has not been set - call sql_generate first")
        return self._table_in

    @property
    def table_out(self) -> str:
        """
        Get the name of the temporary table generated by executing this criterion.
        """
        if self._table_out is None:
            raise ValueError("table_out has not been set - call sql_generate first")
        return self._table_out

    def _sql_header(self, table_in: str | None, table_out: str) -> str:
        """
        Generate the header of the SQL query.
        """
        self._table_in = table_in
        self._table_out = table_out
        return f"SELECT DISTINCT person_id\nINTO {table_out} AS table_out \nFROM {table_in} AS table_in\n"

    @abstractmethod
    def _sql_generate(self, sql_select: str) -> str:
        """
        Get the SQL representation of the criterion.
        """
        raise NotImplementedError()

    def sql_generate(self, table_in: str | None, table_out: str) -> str:
        """
        Get the SQL representation of the criterion.
        """
        sql = self._sql_header(table_in, table_out)
        sql = self._sql_generate(sql)
        sql = self._sql_post_process(sql)
        return sql

    def _sql_post_process(self, sql: str) -> str:
        if self._exclude:
            sql = f"(SELECT person_id FROM {self.table_in}) EXCEPT ({sql})"  # nosec - this is actual SQL code (generated)
        # sql = sqlparse.format(sql, reindent=True, keyword_case="upper")
        # fixme remove or replace sqlparse (not working due to use of sqlalchemy)
        return sql

    def sql_select(self) -> str:
        """
        Get the SQL to select the person_id column from the temporary table generated by executing this criterion.
        """

        sql = f"SELECT person_id FROM {self.table_out}"  # nosec - this is actual SQL code (generated)

        return self._sql_post_process(sql)

    def sql_cleanup(self) -> str:
        """
        Get the SQL to drop the temporary table generated by executing this criterion.
        """
        return f"DROP table {self.table_out}"
