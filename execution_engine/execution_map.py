import logging
from itertools import chain
from typing import Iterator

import sympy

import execution_engine.util.cohort_logic as logic
from execution_engine.constants import CohortCategory
from execution_engine.omop.criterion.abstract import Criterion
from execution_engine.omop.criterion.combination import CriterionCombination
from execution_engine.task.creator import TaskCreator
from execution_engine.task.task import Task


class ExecutionMap:
    """
    ExecutionMap generates an SQL execution strategy for an Recommendation represented as a collection of criteria.

    The execution map is a tree of criteria that can be executed in a sequential manner. The execution map is generated by
    converting the criterion combination into a negation normal form (NNF) and then flattening the tree into a sequential
    execution map.

    The advantage of the negation normal form (NNF)-based representation of the criterion combination
    is that in the NNF, the negation operator is only applied to single criteria, and not to combinations of criteria.
    This allows us to push the negation operator into the criteria themselves, which simplifies the execution strategy.
    """

    _expr: logic.Expr

    def __init__(
        self, comb: CriterionCombination, base_criterion: Criterion, params: dict | None
    ) -> None:
        """
        Initialize the execution map with a criterion combination.

        :param comb: The criterion combination.
        :param base_criterion: The base criterion which is executed first and used to limit the number of patients
            that are considered for the execution of the other criteria.
        """
        self._criteria = comb
        self._expr = self._to_expression(self._criteria)
        self._base_criterion = base_criterion
        self._params = params
        self._root_task = self._create_execution_map()

        logging.info(f"Expression: {self._expr}")

    def root_task(self) -> Task:
        """
        Return the root task of the execution map.
        """
        return self._root_task

    @property
    def category(self) -> CohortCategory:
        """
        Get the category of the execution map.
        """
        return self.get_combined_category(self)

    @staticmethod
    def get_combined_category(*emaps: "ExecutionMap") -> CohortCategory:
        """
        Get the combined category of multiple execution maps.

        The combined category is the category of the criterion combination that is created by combining
        the criteria represented by the execution maps.

        BASE is returned only if all execution maps have the category BASE.
        POPULATION is returned if all execution maps have the category POPULATION or BASE.
        INTERVENTION is returned if all execution maps have the category INTERVENTION or BASE.
        POPULATION_INTERVENTION is returned otherwise.

        :param emaps: The execution maps.
        :return: The combined category.
        """
        assert all(
            isinstance(arg, ExecutionMap) for arg in emaps
        ), "all args must be instance of ExecutionMap"

        criteria = list(chain.from_iterable(arg.flatten() for arg in emaps))

        if all(c.category == CohortCategory.BASE for c in criteria):
            category = CohortCategory.BASE
        elif all(
            c.category == CohortCategory.POPULATION or c.category == CohortCategory.BASE
            for c in criteria
        ):
            category = CohortCategory.POPULATION
        elif all(
            c.category == CohortCategory.INTERVENTION
            or c.category == CohortCategory.BASE
            for c in criteria
        ):
            category = CohortCategory.INTERVENTION
        else:
            category = CohortCategory.POPULATION_INTERVENTION

        return category

    def __combine__(self, other: "ExecutionMap", operator: str) -> "ExecutionMap":
        """
        Combine two execution maps with an operator.
        """
        assert isinstance(other, ExecutionMap), "other must be instance of ExecutionMap"
        assert (
            self._base_criterion == other._base_criterion
        ), "base criteria must be equal"

        assert (
            self._params is None and other._params is None
        ) or self._params == other._params, "params must be equal"

        criteria = [self._criteria, other._criteria]
        category = self.get_combined_category(self, other)

        return ExecutionMap(
            CriterionCombination(
                "CriterionCombination",  # todo: proper name
                exclude=False,
                operator=CriterionCombination.Operator(operator),
                category=category,
                criteria=criteria,
            ),
            self._base_criterion,
            self._params,
        )

    def __and__(self, other: "ExecutionMap") -> "ExecutionMap":
        """
        Combine two execution maps with an AND operator.
        """
        return self.__combine__(other, CriterionCombination.Operator.AND)

    def __or__(self, other: "ExecutionMap") -> "ExecutionMap":
        """
        Combine two execution maps with an OR operator.
        """
        return self.__combine__(other, CriterionCombination.Operator.OR)

    def __invert__(self) -> "ExecutionMap":
        """
        Invert the execution map.
        """
        return ExecutionMap(self._criteria.invert(), self._base_criterion, self._params)

    @classmethod
    def union(cls, *args: "ExecutionMap") -> "ExecutionMap":
        """
        Combine multiple execution maps with an OR operator.
        """
        assert all(
            isinstance(arg, ExecutionMap) for arg in args
        ), "all args must be instance of ExecutionMap"

        # assert that all arg's base criteria are equal
        assert (
            len(set(arg._base_criterion for arg in args)) == 1
        ), "base criteria must be equal"

        assert all(arg._params is None for arg in args) or (
            all(arg._params == args[0]._params for arg in args)
        ), "params must be equal"

        criteria = [arg._criteria for arg in args]
        category = cls.get_combined_category(*args)

        return cls(
            CriterionCombination(
                "OR",
                exclude=False,
                operator=CriterionCombination.Operator(
                    CriterionCombination.Operator.OR
                ),
                category=category,
                criteria=criteria,
            ),
            args[0]._base_criterion,
            args[0]._params,
        )

    def _create_execution_map(self) -> Task:
        def count_usage(expr: logic.Expr, usage_count: dict[logic.Expr, int]) -> None:
            usage_count[expr] = usage_count.get(expr, 0) + 1
            if not expr.is_Atom:
                for arg in expr.args:
                    count_usage(arg, usage_count)

        usage_counts: dict[logic.Expr, int] = {}
        count_usage(self._expr, usage_counts)

        tc = TaskCreator(base_criterion=self._base_criterion, params=self._params)

        return tc.create_tasks_and_dependencies(self._expr)

    @staticmethod
    def _to_expression(comb: CriterionCombination) -> logic.Expr:
        """
        Convert the criterion combination into a logic expression and a hashmap of
        criteria by their name used in the NNF. This is a workaround because we are using sympy for the NNF conversion
        and sympy seems not to allow adding custom attributes to the expression tree.
        """
        # todo: update docstring

        def conjunction_from_operator(
            operator: CriterionCombination.Operator,
        ) -> sympy.Expr:
            """
            Convert the criterion's operator into a sympy conjunction (And or Or)
            """
            if operator.operator == CriterionCombination.Operator.AND:
                return logic.And
            elif operator.operator == CriterionCombination.Operator.OR:
                return logic.Or
            else:
                raise NotImplementedError(f'Operator "{str(operator)}" not implemented')

        def _traverse(comb: CriterionCombination) -> logic.Symbol:
            """
            Traverse the criterion combination and creates a collection of sympy conjunctions from it.
            """
            conjunction = conjunction_from_operator(comb.operator)
            symbols = []

            for entry in comb:
                if isinstance(entry, CriterionCombination):
                    symbols.append(_traverse(entry))
                else:
                    entry_name = entry.unique_name()
                    s = logic.Symbol(entry_name, criterion=entry)
                    if entry.exclude:
                        s = logic.Not(s, category=entry.category)
                    symbols.append(s)

            c = conjunction(*symbols, category=comb.category)

            if comb.exclude:
                c = logic.Not(c, category=comb.category)

            return c

        conj = _traverse(comb)

        return conj

    def flatten(self) -> Iterator[Criterion]:
        """
        Flatten the execution map into a list of criteria.
        """

        def _traverse(comb: CriterionCombination) -> list[Criterion]:
            criteria = []
            for element in comb:
                if isinstance(element, CriterionCombination):
                    criteria += _traverse(element)
                else:
                    criteria.append(element)
            return criteria

        yield from _traverse(self._criteria)
